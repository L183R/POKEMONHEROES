 (cd "$(git rev-parse --show-toplevel)" && git apply --3way <<'EOF' 
diff --git a/hangman.py b/hangman.py
index bf4a3027c51bc70424d8ba03f631412aab98e2be..f2211abed58caa60837830d16dd1d4146a0f5029 100644
--- a/hangman.py
+++ b/hangman.py
@@ -328,50 +328,55 @@ def auto_guess_loop(sess, cookies, wordlist, soup, raw_word, used, wrong):
         print_state(raw_word, soup)
         used, wrong = extract_used_and_wrong_letters(soup, raw_word)
         if raw_word and "_" not in raw_word:
             word_upper = raw_word.upper().strip()
             bank = load_wordlist(WORDLIST_PATH)
             if word_upper not in [w.upper() for w in bank]:
                 with WORDLIST_PATH.open("a", encoding="utf-8") as f:
                     f.write(word_upper + "\n")
                 print(f"\nâœ… Palabra agregada al banco: {word_upper}")
         _, _, lives = grab_metrics(soup)
         if round_finished(raw_word, lives):
             break
         tries += 1
         time.sleep(AUTO_GUESS_SLEEP_SEC)
     return raw_word, soup
 
 def fallback_guess_loop(sess, cookies, soup, raw_word, used, wrong):
     """
     Sin candidatas: probar letras por frecuencia en inglÃ©s (excluye usadas).
     """
     pool = [ch for ch in FALLBACK_FREQ_ORDER if ch not in used]
     if not pool:
         print("\n(No hay letras disponibles para fallback)")
         return raw_word, soup
 
+    # Si la ronda ya terminÃ³ (sin vidas o palabra completa), no intentes fallback
+    _, _, lives = grab_metrics(soup)
+    if round_finished(raw_word, lives):
+        return raw_word, soup
+
     tries = 0
     for next_letter in pool:
         if tries >= FALLBACK_MAX_PER_ROUND:
             break
         print(f"\nðŸ¤– Fallback: probando {next_letter} (sin candidatas)")
         html = request_page(sess, cookies, next_letter)
         soup = BeautifulSoup(html, "html.parser")
         raw_word = find_word(soup, html)
         print_state(raw_word, soup)
         used, wrong = extract_used_and_wrong_letters(soup, raw_word)
         if raw_word and "_" not in raw_word:
             word_upper = raw_word.upper().strip()
             bank = load_wordlist(WORDLIST_PATH)
             if word_upper not in [w.upper() for w in bank]:
                 with WORDLIST_PATH.open("a", encoding="utf-8") as f:
                     f.write(word_upper + "\n")
                 print(f"\nâœ… Palabra agregada al banco: {word_upper}")
         _, _, lives = grab_metrics(soup)
         if round_finished(raw_word, lives):
             break
         tries += 1
         time.sleep(FALLBACK_SLEEP_SEC)
     return raw_word, soup
 
 def main():
 
EOF
)