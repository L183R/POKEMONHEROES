 (cd "$(git rev-parse --show-toplevel)" && git apply --3way <<'EOF' 
diff --git a/hangman.py b/hangman.py
index bf4a3027c51bc70424d8ba03f631412aab98e2be..9867cf5bfc851569ebb916371b25dcb6c81174e5 100644
--- a/hangman.py
+++ b/hangman.py
@@ -319,69 +319,79 @@ def auto_guess_loop(sess, cookies, wordlist, soup, raw_word, used, wrong):
             break
         ranking = rank_letters(candidates, used_letters=used)
         if not ranking:
             break
         next_letter = ranking[0][0]
         print(f"\nü§ñ Auto: probando {next_letter} (top entre {len(candidates)} candidatas)")
         html = request_page(sess, cookies, next_letter)
         soup = BeautifulSoup(html, "html.parser")
         raw_word = find_word(soup, html)
         print_state(raw_word, soup)
         used, wrong = extract_used_and_wrong_letters(soup, raw_word)
         if raw_word and "_" not in raw_word:
             word_upper = raw_word.upper().strip()
             bank = load_wordlist(WORDLIST_PATH)
             if word_upper not in [w.upper() for w in bank]:
                 with WORDLIST_PATH.open("a", encoding="utf-8") as f:
                     f.write(word_upper + "\n")
                 print(f"\n‚úÖ Palabra agregada al banco: {word_upper}")
         _, _, lives = grab_metrics(soup)
         if round_finished(raw_word, lives):
             break
         tries += 1
         time.sleep(AUTO_GUESS_SLEEP_SEC)
     return raw_word, soup
 
-def fallback_guess_loop(sess, cookies, soup, raw_word, used, wrong):
+def fallback_guess_loop(sess, cookies, soup, raw_word, used, wrong, wordlist):
     """
     Sin candidatas: probar letras por frecuencia en ingl√©s (excluye usadas).
+    Tras cada intento se verifica si ahora hay coincidencias en el banco.
     """
     pool = [ch for ch in FALLBACK_FREQ_ORDER if ch not in used]
     if not pool:
         print("\n(No hay letras disponibles para fallback)")
         return raw_word, soup
 
     tries = 0
     for next_letter in pool:
         if tries >= FALLBACK_MAX_PER_ROUND:
             break
-        print(f"\nü§ñ Fallback: probando {next_letter} (sin candidatas)")
+        print(f"\nü§ñ Fallback: probando {next_letter} (sin candidatas previas)")
         html = request_page(sess, cookies, next_letter)
         soup = BeautifulSoup(html, "html.parser")
         raw_word = find_word(soup, html)
         print_state(raw_word, soup)
         used, wrong = extract_used_and_wrong_letters(soup, raw_word)
+
+        # Ver si ahora hay candidatas y salir del fallback
+        candidates = [w for w in wordlist if matches_pattern(w, raw_word, wrong_letters=wrong)]
+        if candidates:
+            print(f"\nCandidatas ({len(candidates)}):")
+            for w in candidates:
+                print(f"- {w}")
+            break
+
         if raw_word and "_" not in raw_word:
             word_upper = raw_word.upper().strip()
             bank = load_wordlist(WORDLIST_PATH)
             if word_upper not in [w.upper() for w in bank]:
                 with WORDLIST_PATH.open("a", encoding="utf-8") as f:
                     f.write(word_upper + "\n")
                 print(f"\n‚úÖ Palabra agregada al banco: {word_upper}")
         _, _, lives = grab_metrics(soup)
         if round_finished(raw_word, lives):
             break
         tries += 1
         time.sleep(FALLBACK_SLEEP_SEC)
     return raw_word, soup
 
 def main():
     cookies = cookies_from_string(COOKIE_STRING)
     wordlist = load_wordlist(WORDLIST_PATH)
 
     with requests.Session() as sess:
         # GET inicial
         try:
             _ = request_page(sess, cookies, None)
         except Exception as e:
             print(f"Error inicial: {e}")
             return
diff --git a/hangman.py b/hangman.py
index bf4a3027c51bc70424d8ba03f631412aab98e2be..9867cf5bfc851569ebb916371b25dcb6c81174e5 100644
--- a/hangman.py
+++ b/hangman.py
@@ -452,51 +462,51 @@ def main():
                             print("\nLetras por frecuencia: (sin sugerencias; todas intentadas)")
                         if AUTO_GUESS_WHEN_CANDIDATES:
                             raw_word, soup = auto_guess_loop(sess, cookies, wordlist, soup, raw_word, used, wrong)
                     else:
                         print("\nCandidatas (shape) (0): (ninguna en el banco para ese patr√≥n)")
 
                 # Flujo normal: candidatas por patr√≥n actual
                 candidates = [w for w in wordlist if matches_pattern(w, raw_word, wrong_letters=wrong)]
                 if candidates:
                     print(f"\nCandidatas ({len(candidates)}):")
                     for w in candidates:
                         print(f"- {w}")
                     ranked = rank_letters(candidates, used_letters=used)
                     if ranked:
                         top_line = " ".join(f"{ltr}:{cnt}" for ltr, cnt in ranked[:15])
                         print("\nLetras por frecuencia (excluyendo intentadas):")
                         print(top_line)
                     else:
                         print("\nLetras por frecuencia: (sin sugerencias; todas intentadas)")
                     if AUTO_GUESS_WHEN_CANDIDATES:
                         raw_word, soup = auto_guess_loop(sess, cookies, wordlist, soup, raw_word, used, wrong)
                 else:
                     print("\nCandidatas (0): (ninguna con ese patr√≥n en el banco)")
                     # Fallback: probar letras por frecuencia global si no hay candidatas
                     if FALLBACK_GUESS_WHEN_NO_CANDIDATES:
-                        raw_word, soup = fallback_guess_loop(sess, cookies, soup, raw_word, used, wrong)
+                        raw_word, soup = fallback_guess_loop(sess, cookies, soup, raw_word, used, wrong, wordlist)
 
                 # Guardar si qued√≥ completa
                 if raw_word and "_" not in raw_word:
                     word_upper = raw_word.upper().strip()
                     if word_upper not in [w.upper() for w in wordlist]:
                         with WORDLIST_PATH.open("a", encoding="utf-8") as f:
                             f.write(word_upper + "\n")
                         wordlist.append(word_upper)
                         print(f"\n‚úÖ Palabra agregada al banco: {word_upper}")
                     else:
                         print(f"\n‚ÑπÔ∏è Palabra ya estaba en el banco: {word_upper}")
 
             # Fin de ronda ‚Üí refrescar
             _, _, lives = grab_metrics(soup)
             if round_finished(raw_word, lives):
                 print("\nüîÑ Ronda terminada. Refrescando para nueva palabra...")
                 try:
                     html2 = refresh_round(sess, cookies)
                 except Exception as e:
                     print(f"Error al refrescar: {e}")
                     continue
                 soup2 = BeautifulSoup(html2, "html.parser")
                 new_raw = find_word(soup2, html2)
                 print("\n‚Äî Nueva ronda ‚Äî")
                 print_state(new_raw, soup2)
 
EOF
)