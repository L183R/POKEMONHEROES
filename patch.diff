 (cd "$(git rev-parse --show-toplevel)" && git apply --3way <<'EOF' 
diff --git a/hangman.py b/hangman.py
index bf4a3027c51bc70424d8ba03f631412aab98e2be..dfa2eb29bed3d4cd626495d6c23f3eb6ee377723 100644
--- a/hangman.py
+++ b/hangman.py
@@ -133,96 +133,119 @@ def find_word(soup: BeautifulSoup, html: str) -> str | None:
     plain = normalize_text(soup.get_text(" ", strip=True)).upper()
     for m2 in re.finditer(r"[A-Z_ ]{3,}", plain):
         t = m2.group(0)
         if "_" in t and re.fullmatch(r"[A-Z_ ]+", t):
             return t
     return None
 
 def is_instruction_banner_text(text_upper: str) -> bool:
     """
     Detecta el banner de instrucciones (cuando en Word aparece el texto largo).
     """
     # Señales robustas (inglés del sitio):
     return (
         "INSTRUCTIONS" in text_upper and
         "HANGMAN GAME" in text_upper and
         "RANDOMLY SELECTS" in text_upper
     )
 
 def grab_metrics(soup: BeautifulSoup) -> tuple[str, str, str]:
     txt = normalize_text(soup.get_text(" ", strip=True))
     def rx(label):
         m = re.search(rf"{re.escape(label)}:\s*(\d+)", txt, re.I)
         return m.group(1) if m else "?"
     return rx("Solved Hangmen in a row"), rx("Correct Guesses"), rx("Lives left")
 
+# --- Estadísticas de rondas y monedas ---
+_last_streak: int | None = None
+_max_streak = 0
+
+def _update_round_stats(solved_str: str) -> None:
+    """Actualiza y muestra rondas, máximo y monedas según la racha actual."""
+    global _last_streak, _max_streak
+    if not solved_str.isdigit():
+        return
+    current = int(solved_str)
+
+    changed = (_last_streak is None) or (current != _last_streak)
+    if not changed:
+        return
+
+    _last_streak = current
+    if current > _max_streak:
+        _max_streak = current
+
+    coins = current * 25
+    print(f"Rondas: {current} | Máximo: {_max_streak} | Monedas: {coins}")
+
 def extract_used_and_wrong_letters(soup: BeautifulSoup, raw_word: str | None) -> tuple[set[str], set[str]]:
     used = set()
     for a in soup.find_all("a", class_="letterGuess"):
         letter = (a.get_text(strip=True) or "").upper()
         if len(letter) == 1 and letter.isalpha() and not a.get("href"):
             used.add(letter)
     letters_in_word = set(ch for ch in (raw_word or "") if ch.isalpha())
     wrong = used - letters_in_word if raw_word else used
     return used, wrong
 
 def headers_common():
     return {
         "user-agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64)",
         "referer": "https://pokeheroes.com/gc_hangman?",
         "accept": "text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8",
         "accept-language": "es-ES,es;q=0.9,en;q=0.8",
         "upgrade-insecure-requests": "1",
     }
 
 def request_page(sess: requests.Session, cookies: dict, letter: str | None):
     params = {"guess": letter} if letter else None
     r = sess.get(URL, params=params, headers=headers_common(), cookies=cookies, timeout=30)
     r.raise_for_status()
     return r.text
 
 def refresh_round(sess: requests.Session, cookies: dict):
     params = {"_": int(time.time() * 1000)}  # cache-buster
     r = sess.get(URL, params=params, headers=headers_common(), cookies=cookies, timeout=30)
     r.raise_for_status()
     return r.text
 
 def is_game_page(soup: BeautifulSoup) -> bool:
     txt = normalize_text(soup.get_text(" ", strip=True))
     return bool(soup.select("a.letterGuess")) or ("Hangman" in txt and "Guess the word" in txt)
 
 def print_state(raw_word: str | None, soup: BeautifulSoup):
     solved, correct, lives = grab_metrics(soup)
     if raw_word:
         print(f"Word: {spaced(raw_word)} ")
     else:
         center = soup.find("center")
         approx = normalize_text(center.get_text(" ", strip=True)).upper() if center else "(vacío)"
         print(f"Word: {spaced(approx)} (palabra no encontrada) ")
     print(f"Solved Hangmen in a row: {solved}")
     print(f"Correct Guesses: {correct}")
     print(f"Lives left: {lives}")
+    _update_round_stats(solved)
     return solved, correct, lives
 
 def round_finished(raw_word: str | None, lives: str | None) -> bool:
     if raw_word and "_" not in raw_word:
         return True
     try:
         return int(lives) <= 0
     except (TypeError, ValueError):
         return False
 
 def auto_refresh_until_word(sess: requests.Session, cookies: dict, interval=2, max_tries=60):
     """
     Autorefresca hasta que aparezca la palabra.
     Si se detecta el banner de INSTRUCTIONS, espera INSTRUCTION_WAIT_SEC entre intentos.
     """
     last_soup = None
     empty_center_hits = 0
 
     for i in range(1, max_tries + 1):
         html = refresh_round(sess, cookies)
         soup = BeautifulSoup(html, "html.parser")
 
         if not is_game_page(soup):
             Path("last_response.html").write_text(html, encoding="utf-8")
             print("\n❌ No llegó la página del juego. Guardé last_response.html")
 
EOF
)