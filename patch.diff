 (cd "$(git rev-parse --show-toplevel)" && git apply --3way <<'EOF' 
diff --git a/hangman.py b/hangman.py
index a81c704475bb8585b74ef8fd914c1c535a0bbe11..1119303b5b4647e6a1a5e596ec2880723d62b75b 100644
--- a/hangman.py
+++ b/hangman.py
@@ -1,94 +1,119 @@
 #!/usr/bin/env python3
 # -*- coding: utf-8 -*-
 
 import sys
 import os
 import re
 import time
 import requests
 from bs4 import BeautifulSoup
 from html import unescape
 from pathlib import Path
 from collections import Counter
 import builtins
 import atexit
 
 # ========= CONFIG =========
 URL = "https://pokeheroes.com/gc_hangman"
 COOKIE_STRING = "PHPSESSID=pdnh5fl1jvn139c0l0rglmug7s; _gcl_au=1.1.1884119554.1756846145.1072503122.1756846377.1756846377; username=L183R; password=6299ad21b8644aa31efb9e2ed4d660160c5480d44dac3f9a090179086e8db991b39e11d5f4b959a13df5f863aebaba997753ef0392427a3c519b48f425b1f6e8; username=L183R; password=6299ad21b8644aa31efb9e2ed4d660160c5480d44dac3f9a090179086e8db991b39e11d5f4b959a13df5f863aebaba997753ef0392427a3c519b48f425b1f6e8; friendbar_hide=hide"  # ← poné tu PHPSESSID válido
 WORDLIST_PATH = Path("hangman_words.txt")
 LOG_PATH = Path("log.txt")
+RESULTS_PATH = Path("results.txt")
 
 # Autorefresco cuando NO se encuentra la palabra
 AUTO_REFRESH_ON_FALLBACK = True
 REFRESH_INTERVAL_SEC = 2
 MAX_REFRESH_TRIES = 60
 
 # Cuando aparece el banner de INSTRUCTIONS, esperar 5 minutos antes de refrescar
 INSTRUCTION_WAIT_SEC = 300  # 5 minutos
 
 # Auto-juego (letra más frecuente entre candidatas)
 AUTO_GUESS_WHEN_CANDIDATES = True
 AUTO_GUESS_MAX_PER_ROUND = 26
 AUTO_GUESS_SLEEP_SEC = 0.6
 
 # Fallback cuando NO hay candidatas: orden de frecuencia en inglés
 FALLBACK_GUESS_WHEN_NO_CANDIDATES = True
 FALLBACK_FREQ_ORDER = "ETAOINSHRDLUCMFYWGPBVKXQJZ"
 FALLBACK_MAX_PER_ROUND = 26
 FALLBACK_SLEEP_SEC = 0.5
 
 # Timeout de input (auto-ENTER)
 INPUT_TIMEOUT_SEC = 5
 # ==========================
 
 if os.name == "nt":
     import msvcrt  # Windows
 
 # === Logging setup ===
 _original_print = builtins.print
 _logged_messages: list[str] = []
 
+current_streak = 0
+max_streak = 0
+total_coins = 0
+
 def log_print(*args, sep=" ", end="\n", **kwargs):
     msg = sep.join(str(a) for a in args) + end
     _logged_messages.append(msg.rstrip("\n"))
     with LOG_PATH.open("a", encoding="utf-8") as f:
         f.write(msg)
 
 builtins.print = log_print
 
 def _print_last_message():
     if _logged_messages:
         _original_print(_logged_messages[-1])
 
 atexit.register(_print_last_message)
 # ======================
 
 def log_round_result(raw_word: str | None) -> None:
+    global current_streak, max_streak, total_coins
     success = bool(raw_word and "_" not in raw_word)
-    log_print(f"RESULT: {raw_word or '-'} - {'SUCCESS' if success else 'FAIL'}")
+    result_text = f"{raw_word or '-'} - {'SUCCESS' if success else 'FAIL'}"
+    log_print(f"RESULT: {result_text}")
+    with RESULTS_PATH.open("a", encoding="utf-8") as f:
+        f.write(result_text + "\n")
+    if success:
+        coins = (current_streak + 1) * 25
+        total_coins += coins
+        current_streak += 1
+        if current_streak > max_streak:
+            max_streak = current_streak
+    else:
+        current_streak = 0
+    os.system("cls" if os.name == "nt" else "clear")
+    for line in (
+        f"Racha actual: {current_streak}",
+        f"Racha máxima: {max_streak}",
+        f"Total de monedas ganadas: {total_coins}",
+    ):
+        log_print(line)
+        _original_print(line)
 
 def cookies_from_string(s: str) -> dict:
     d = {}
     for part in [p.strip() for p in s.split(";") if p.strip()]:
         if "=" in part and not part.lower().startswith("expires"):
             k, v = part.split("=", 1)
             d[k.strip()] = v.strip()
     return d
 
 def normalize_text(txt: str) -> str:
     txt = unescape(txt)
     txt = re.sub(r"\xa0{2,}", " ", txt)
     txt = txt.replace("\xa0", "")
     return re.sub(r"[ \t\r\f\v]+", " ", txt).strip()
 
 
 def parse_game_word(raw: str) -> str:
     raw = unescape(raw).replace("\xa0", " ").upper()
     raw = re.sub(r"[^A-Z_ ]+", "", raw)
     out: list[str] = []
     i = 0
     while i < len(raw):
         if raw[i] == " ":
             j = i
             while j < len(raw) and raw[j] == " ":
 
EOF
)