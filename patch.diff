 (cd "$(git rev-parse --show-toplevel)" && git apply --3way <<'EOF' 
diff --git a/hangman.py b/hangman.py
index bf4a3027c51bc70424d8ba03f631412aab98e2be..6b818941681e057a58332d663cc78c1089fcdf7c 100644
--- a/hangman.py
+++ b/hangman.py
@@ -48,52 +48,56 @@ def cookies_from_string(s: str) -> dict:
         if "=" in part and not part.lower().startswith("expires"):
             k, v = part.split("=", 1)
             d[k.strip()] = v.strip()
     return d
 
 def normalize_text(txt: str) -> str:
     txt = unescape(txt).replace("\xa0", " ")
     return re.sub(r"[ \t\r\f\v]+", " ", txt)
 
 def load_wordlist(path: Path) -> list[str]:
     if not path.exists():
         return []
     return [line.strip() for line in path.read_text(encoding="utf-8").splitlines() if line.strip()]
 
 def spaced(s: str) -> str:
     return " ".join(list(s))
 
 def matches_pattern(candidate: str, raw_game_word: str, wrong_letters: set[str] | None = None) -> bool:
     """
     - misma longitud/espacios que el patr√≥n
     - respeta letras reveladas
     - '_' acepta letra (no espacio)
     - NO repite una letra revelada en posiciones ocultas
     - excluye letras fallidas
     """
-    cand = candidate.upper()
-    patt = raw_game_word.upper()
+    # Algunas fuentes del juego insertan espacios entre caracteres (p.ej. "_ _ _ _").
+    # Para comparar correctamente contra el banco de palabras, ignoramos esos
+    # espacios artificiales. Conservamos las letras tal cual para respetar
+    # patrones con caracteres revelados y las posiciones reales.
+    cand = candidate.upper().replace(" ", "")
+    patt = raw_game_word.upper().replace(" ", "")
     if len(cand) != len(patt):
         return False
 
     revealed_positions: dict[str, set[int]] = {}
     for i, (pc, cc) in enumerate(zip(patt, cand)):
         if pc == " ":
             if cc != " ":
                 return False
         elif pc == "_":
             if cc == " ":
                 return False
         elif pc.isalpha():
             if cc != pc:
                 return False
             revealed_positions.setdefault(pc, set()).add(i)
         else:
             if cc != pc:
                 return False
 
     for letter, pos_set in revealed_positions.items():
         for i, cc in enumerate(cand):
             if i not in pos_set and cc == letter:
                 return False
 
     if wrong_letters:
 
EOF
)