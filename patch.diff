 (cd "$(git rev-parse --show-toplevel)" && git apply --3way <<'EOF' 
diff --git a/hangman.py b/hangman.py
index bf4a3027c51bc70424d8ba03f631412aab98e2be..d87f348f102a9676f631270567c48b6461c9a295 100644
--- a/hangman.py
+++ b/hangman.py
@@ -319,63 +319,78 @@ def auto_guess_loop(sess, cookies, wordlist, soup, raw_word, used, wrong):
             break
         ranking = rank_letters(candidates, used_letters=used)
         if not ranking:
             break
         next_letter = ranking[0][0]
         print(f"\nðŸ¤– Auto: probando {next_letter} (top entre {len(candidates)} candidatas)")
         html = request_page(sess, cookies, next_letter)
         soup = BeautifulSoup(html, "html.parser")
         raw_word = find_word(soup, html)
         print_state(raw_word, soup)
         used, wrong = extract_used_and_wrong_letters(soup, raw_word)
         if raw_word and "_" not in raw_word:
             word_upper = raw_word.upper().strip()
             bank = load_wordlist(WORDLIST_PATH)
             if word_upper not in [w.upper() for w in bank]:
                 with WORDLIST_PATH.open("a", encoding="utf-8") as f:
                     f.write(word_upper + "\n")
                 print(f"\nâœ… Palabra agregada al banco: {word_upper}")
         _, _, lives = grab_metrics(soup)
         if round_finished(raw_word, lives):
             break
         tries += 1
         time.sleep(AUTO_GUESS_SLEEP_SEC)
     return raw_word, soup
 
-def fallback_guess_loop(sess, cookies, soup, raw_word, used, wrong):
+def fallback_guess_loop(sess, cookies, soup, raw_word, used, wrong, wordlist):
     """
     Sin candidatas: probar letras por frecuencia en inglÃ©s (excluye usadas).
+    Revisa el banco antes de cada intento para ver si ya hay candidatas.
     """
     pool = [ch for ch in FALLBACK_FREQ_ORDER if ch not in used]
     if not pool:
         print("\n(No hay letras disponibles para fallback)")
         return raw_word, soup
 
     tries = 0
-    for next_letter in pool:
-        if tries >= FALLBACK_MAX_PER_ROUND:
+    while pool and tries < FALLBACK_MAX_PER_ROUND:
+        # Revisar si ya existen candidatas antes de adivinar la siguiente letra
+        candidates = [w for w in wordlist if matches_pattern(w, raw_word, wrong_letters=wrong)]
+        if candidates:
+            print(f"\nCandidatas ({len(candidates)}):")
+            for w in candidates:
+                print(f"- {w}")
+            ranked = rank_letters(candidates, used_letters=used)
+            if ranked:
+                top_line = " ".join(f"{ltr}:{cnt}" for ltr, cnt in ranked[:15])
+                print("\nLetras por frecuencia (excluyendo intentadas):")
+                print(top_line)
+            if AUTO_GUESS_WHEN_CANDIDATES:
+                raw_word, soup = auto_guess_loop(sess, cookies, wordlist, soup, raw_word, used, wrong)
             break
+
+        next_letter = pool.pop(0)
         print(f"\nðŸ¤– Fallback: probando {next_letter} (sin candidatas)")
         html = request_page(sess, cookies, next_letter)
         soup = BeautifulSoup(html, "html.parser")
         raw_word = find_word(soup, html)
         print_state(raw_word, soup)
         used, wrong = extract_used_and_wrong_letters(soup, raw_word)
         if raw_word and "_" not in raw_word:
             word_upper = raw_word.upper().strip()
             bank = load_wordlist(WORDLIST_PATH)
             if word_upper not in [w.upper() for w in bank]:
                 with WORDLIST_PATH.open("a", encoding="utf-8") as f:
                     f.write(word_upper + "\n")
                 print(f"\nâœ… Palabra agregada al banco: {word_upper}")
         _, _, lives = grab_metrics(soup)
         if round_finished(raw_word, lives):
             break
         tries += 1
         time.sleep(FALLBACK_SLEEP_SEC)
     return raw_word, soup
 
 def main():
     cookies = cookies_from_string(COOKIE_STRING)
     wordlist = load_wordlist(WORDLIST_PATH)
 
     with requests.Session() as sess:
diff --git a/hangman.py b/hangman.py
index bf4a3027c51bc70424d8ba03f631412aab98e2be..d87f348f102a9676f631270567c48b6461c9a295 100644
--- a/hangman.py
+++ b/hangman.py
@@ -452,51 +467,53 @@ def main():
                             print("\nLetras por frecuencia: (sin sugerencias; todas intentadas)")
                         if AUTO_GUESS_WHEN_CANDIDATES:
                             raw_word, soup = auto_guess_loop(sess, cookies, wordlist, soup, raw_word, used, wrong)
                     else:
                         print("\nCandidatas (shape) (0): (ninguna en el banco para ese patrÃ³n)")
 
                 # Flujo normal: candidatas por patrÃ³n actual
                 candidates = [w for w in wordlist if matches_pattern(w, raw_word, wrong_letters=wrong)]
                 if candidates:
                     print(f"\nCandidatas ({len(candidates)}):")
                     for w in candidates:
                         print(f"- {w}")
                     ranked = rank_letters(candidates, used_letters=used)
                     if ranked:
                         top_line = " ".join(f"{ltr}:{cnt}" for ltr, cnt in ranked[:15])
                         print("\nLetras por frecuencia (excluyendo intentadas):")
                         print(top_line)
                     else:
                         print("\nLetras por frecuencia: (sin sugerencias; todas intentadas)")
                     if AUTO_GUESS_WHEN_CANDIDATES:
                         raw_word, soup = auto_guess_loop(sess, cookies, wordlist, soup, raw_word, used, wrong)
                 else:
                     print("\nCandidatas (0): (ninguna con ese patrÃ³n en el banco)")
                     # Fallback: probar letras por frecuencia global si no hay candidatas
                     if FALLBACK_GUESS_WHEN_NO_CANDIDATES:
-                        raw_word, soup = fallback_guess_loop(sess, cookies, soup, raw_word, used, wrong)
+                        raw_word, soup = fallback_guess_loop(
+                            sess, cookies, soup, raw_word, used, wrong, wordlist
+                        )
 
                 # Guardar si quedÃ³ completa
                 if raw_word and "_" not in raw_word:
                     word_upper = raw_word.upper().strip()
                     if word_upper not in [w.upper() for w in wordlist]:
                         with WORDLIST_PATH.open("a", encoding="utf-8") as f:
                             f.write(word_upper + "\n")
                         wordlist.append(word_upper)
                         print(f"\nâœ… Palabra agregada al banco: {word_upper}")
                     else:
                         print(f"\nâ„¹ï¸ Palabra ya estaba en el banco: {word_upper}")
 
             # Fin de ronda â†’ refrescar
             _, _, lives = grab_metrics(soup)
             if round_finished(raw_word, lives):
                 print("\nðŸ”„ Ronda terminada. Refrescando para nueva palabra...")
                 try:
                     html2 = refresh_round(sess, cookies)
                 except Exception as e:
                     print(f"Error al refrescar: {e}")
                     continue
                 soup2 = BeautifulSoup(html2, "html.parser")
                 new_raw = find_word(soup2, html2)
                 print("\nâ€” Nueva ronda â€”")
                 print_state(new_raw, soup2)
 
EOF
)