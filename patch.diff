 (cd "$(git rev-parse --show-toplevel)" && git apply --3way <<'EOF' 
diff --git a/hangman.py b/hangman.py
index bf4a3027c51bc70424d8ba03f631412aab98e2be..8ef68138e330b4fc3e68da393553c5ee44b5e45c 100644
--- a/hangman.py
+++ b/hangman.py
@@ -291,93 +291,175 @@ def timed_input(prompt: str, timeout: int) -> str:
                     if buf:
                         buf.pop()
                         print("\b \b", end="", flush=True)
                 else:
                     buf.append(ch)
                     print(ch, end="", flush=True)
             if time.time() - start >= timeout:
                 print()
                 return ""
             time.sleep(0.05)
     else:
         import select
         rlist, _, _ = select.select([sys.stdin], [], [], timeout)
         if rlist:
             line = sys.stdin.readline()
             return line.rstrip("\n")
         else:
             print()
             return ""
 
 def auto_guess_loop(sess, cookies, wordlist, soup, raw_word, used, wrong):
     """
     Con candidatas: intentar letras m√°s frecuentes (excluyendo usadas).
     """
     tries = 0
+    pending_letters: list[str] = []
     while AUTO_GUESS_WHEN_CANDIDATES and tries < AUTO_GUESS_MAX_PER_ROUND:
         candidates = [w for w in wordlist if matches_pattern(w, raw_word, wrong_letters=wrong)]
         if not candidates:
             break
-        ranking = rank_letters(candidates, used_letters=used)
+        ranking = rank_letters(candidates, used_letters=used.union(set(pending_letters)))
         if not ranking:
             break
         next_letter = ranking[0][0]
         print(f"\nü§ñ Auto: probando {next_letter} (top entre {len(candidates)} candidatas)")
-        html = request_page(sess, cookies, next_letter)
+        try:
+            html = request_page(sess, cookies, next_letter)
+        except Exception as e:
+            print(f"‚ö†Ô∏è Error al probar {next_letter}: {e}. Se reintentar√° despu√©s.")
+            pending_letters.append(next_letter)
+            tries += 1
+            time.sleep(AUTO_GUESS_SLEEP_SEC)
+            continue
+        soup = BeautifulSoup(html, "html.parser")
+        raw_word_new = find_word(soup, html)
+        print_state(raw_word_new, soup)
+        used_after, wrong_after = extract_used_and_wrong_letters(soup, raw_word_new)
+        if next_letter not in used_after:
+            print(f"‚ö†Ô∏è Sin respuesta para {next_letter}. Se reintentar√° al final.")
+            pending_letters.append(next_letter)
+        else:
+            raw_word = raw_word_new
+            used, wrong = used_after, wrong_after
+            if raw_word and "_" not in raw_word:
+                word_upper = raw_word.upper().strip()
+                bank = load_wordlist(WORDLIST_PATH)
+                if word_upper not in [w.upper() for w in bank]:
+                    with WORDLIST_PATH.open("a", encoding="utf-8") as f:
+                        f.write(word_upper + "\n")
+                    print(f"\n‚úÖ Palabra agregada al banco: {word_upper}")
+        _, _, lives = grab_metrics(soup)
+        if round_finished(raw_word, lives):
+            break
+        tries += 1
+        time.sleep(AUTO_GUESS_SLEEP_SEC)
+
+    # Reintentar letras que no dieron respuesta
+    for letter in pending_letters:
+        if tries >= AUTO_GUESS_MAX_PER_ROUND:
+            break
+        print(f"\nü§ñ Auto: reintentando {letter} (sin respuesta previa)")
+        try:
+            html = request_page(sess, cookies, letter)
+        except Exception as e:
+            print(f"‚ö†Ô∏è Error al reintentar {letter}: {e}")
+            continue
         soup = BeautifulSoup(html, "html.parser")
         raw_word = find_word(soup, html)
         print_state(raw_word, soup)
         used, wrong = extract_used_and_wrong_letters(soup, raw_word)
         if raw_word and "_" not in raw_word:
             word_upper = raw_word.upper().strip()
             bank = load_wordlist(WORDLIST_PATH)
             if word_upper not in [w.upper() for w in bank]:
                 with WORDLIST_PATH.open("a", encoding="utf-8") as f:
                     f.write(word_upper + "\n")
                 print(f"\n‚úÖ Palabra agregada al banco: {word_upper}")
         _, _, lives = grab_metrics(soup)
         if round_finished(raw_word, lives):
             break
         tries += 1
         time.sleep(AUTO_GUESS_SLEEP_SEC)
     return raw_word, soup
 
 def fallback_guess_loop(sess, cookies, soup, raw_word, used, wrong):
     """
     Sin candidatas: probar letras por frecuencia en ingl√©s (excluye usadas).
     """
     pool = [ch for ch in FALLBACK_FREQ_ORDER if ch not in used]
     if not pool:
         print("\n(No hay letras disponibles para fallback)")
         return raw_word, soup
 
     tries = 0
+    pending_letters: list[str] = []
     for next_letter in pool:
         if tries >= FALLBACK_MAX_PER_ROUND:
             break
         print(f"\nü§ñ Fallback: probando {next_letter} (sin candidatas)")
-        html = request_page(sess, cookies, next_letter)
+        try:
+            html = request_page(sess, cookies, next_letter)
+        except Exception as e:
+            print(f"‚ö†Ô∏è Error al probar {next_letter}: {e}. Se reintentar√° despu√©s.")
+            pending_letters.append(next_letter)
+            tries += 1
+            time.sleep(FALLBACK_SLEEP_SEC)
+            continue
+        soup = BeautifulSoup(html, "html.parser")
+        raw_word_new = find_word(soup, html)
+        print_state(raw_word_new, soup)
+        used_after, wrong_after = extract_used_and_wrong_letters(soup, raw_word_new)
+        if next_letter not in used_after:
+            print(f"‚ö†Ô∏è Sin respuesta para {next_letter}. Se reintentar√° al final.")
+            pending_letters.append(next_letter)
+        else:
+            raw_word = raw_word_new
+            used, wrong = used_after, wrong_after
+            if raw_word and "_" not in raw_word:
+                word_upper = raw_word.upper().strip()
+                bank = load_wordlist(WORDLIST_PATH)
+                if word_upper not in [w.upper() for w in bank]:
+                    with WORDLIST_PATH.open("a", encoding="utf-8") as f:
+                        f.write(word_upper + "\n")
+                    print(f"\n‚úÖ Palabra agregada al banco: {word_upper}")
+        _, _, lives = grab_metrics(soup)
+        if round_finished(raw_word, lives):
+            break
+        tries += 1
+        time.sleep(FALLBACK_SLEEP_SEC)
+
+    # Reintentar letras que no dieron respuesta
+    for letter in pending_letters:
+        if tries >= FALLBACK_MAX_PER_ROUND:
+            break
+        print(f"\nü§ñ Fallback: reintentando {letter} (sin respuesta previa)")
+        try:
+            html = request_page(sess, cookies, letter)
+        except Exception as e:
+            print(f"‚ö†Ô∏è Error al reintentar {letter}: {e}")
+            continue
         soup = BeautifulSoup(html, "html.parser")
         raw_word = find_word(soup, html)
         print_state(raw_word, soup)
         used, wrong = extract_used_and_wrong_letters(soup, raw_word)
         if raw_word and "_" not in raw_word:
             word_upper = raw_word.upper().strip()
             bank = load_wordlist(WORDLIST_PATH)
             if word_upper not in [w.upper() for w in bank]:
                 with WORDLIST_PATH.open("a", encoding="utf-8") as f:
                     f.write(word_upper + "\n")
                 print(f"\n‚úÖ Palabra agregada al banco: {word_upper}")
         _, _, lives = grab_metrics(soup)
         if round_finished(raw_word, lives):
             break
         tries += 1
         time.sleep(FALLBACK_SLEEP_SEC)
     return raw_word, soup
 
 def main():
     cookies = cookies_from_string(COOKIE_STRING)
     wordlist = load_wordlist(WORDLIST_PATH)
 
     with requests.Session() as sess:
         # GET inicial
         try:
 
EOF
)