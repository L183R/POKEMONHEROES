 (cd "$(git rev-parse --show-toplevel)" && git apply --3way <<'EOF' 
diff --git a/Memorygame.py b/Memorygame.py
index e2f99d36f8513c77134217447a7f9428d67ef16e..b9317ca4054b32675b4f4698ae3e438ec9b3f893 100644
--- a/Memorygame.py
+++ b/Memorygame.py
@@ -122,66 +122,64 @@ def load_cookies() -> dict:
         s = os.getenv("PH_COOKIE").strip()
     if not s:
         raise SystemExit("Falta Cookie: pegala en COOKIES_STRING o creá cookies.txt con la cookie en una línea.")
     return parse_cookie_string(s)
 
 def ensure_warmup(session: requests.Session, cookies: dict):
     r = session.get(
         URL_PAGE,
         headers=PAGE_HEADERS,
         cookies=cookies,
         timeout=(10, 30),
         allow_redirects=True,
     )
     log(f"[warmup] {r.status_code} {r.url}")
     low = r.text.lower()
     if any(s in low for s in ["login", "log in", "signin", "sign in"]) and "concentration" not in low:
         log("[warmup-error] Respuesta del servidor:")
         log(r.text)
         raise SystemExit("Parece que no estás logueado. Revisá el log.")
 
 # ---- Parsing de ID (desde bytes) ----
 def extract_card_id_from_bytes(content: bytes, prev_known: str | None = None) -> str | None:
     tokens = re.findall(rb"\d+", content)
     if not tokens:
         return None
-    def last3(t: bytes) -> str:
-        return t[-3:].decode("ascii", errors="ignore").zfill(3)
-    long_tokens = [t for t in tokens if len(t) >= 3]
-    if long_tokens:
-        for t in long_tokens:
-            v = last3(t)
-            if v != "000":
-                return v
-        return last3(long_tokens[0])
-    best = max(tokens, key=len)
-    v = last3(best)
+
+    # La respuesta típica contiene dos números: "0" (éxito) y luego el ID.
+    # Tomamos el último número encontrado como candidato y lo rellenamos a 3 dígitos.
+    candidate = tokens[-1]
+    v = candidate.decode("ascii", errors="ignore").zfill(3)
+
     if v == "000":
         return None
-    if prev_known and v != prev_known and len(best) < 3:
+
+    # Si la cadena es corta y teníamos un valor previo confiable, preferilo.
+    if prev_known and len(candidate) < 3 and v != prev_known:
         return prev_known
-    return v if len(best) >= 3 else None
+
+    return v
 
 # ---- Flip con dos modos: exploratorio vs estricto ----
 def flip_generic(session, cookies, idx: int, expected: str | None,
                  max_retries: int, base_sleep: float, deadline_sec: float) -> str | None:
     start = monotonic()
     backoff = base_sleep
     for attempt in range(1, max_retries + 1):
         if monotonic() - start > deadline_sec:
             log(f"[deadline] idx={idx} {deadline_sec:.1f}s. {'mantengo previo' if expected else 'skip'}")
             return expected  # si teníamos expected, devolvelo; si no, None
 
         try:
             r = session.post(
                 URL_FLIP,
                 headers=XHR_HEADERS,
                 cookies=cookies,
                 data={"card": str(idx)},
                 timeout=(10, 30),
                 allow_redirects=False,
             )
             body = r.text
             log(f"[response] idx={idx} intento {attempt}/{max_retries} status={r.status_code} body={body.strip()}")
 
             # Sólo acá se permite warmup: si el servidor redirige (sesión/nonce caído)
             if 300 <= r.status_code < 400:
 
EOF
)