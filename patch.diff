 (cd "$(git rev-parse --show-toplevel)" && git apply --3way <<'EOF' 
diff --git a/hangman.py b/hangman.py
index bf4a3027c51bc70424d8ba03f631412aab98e2be..154871cccd3fca3b57a7750a2f05bd566f153d97 100644
--- a/hangman.py
+++ b/hangman.py
@@ -170,59 +170,61 @@ def headers_common():
         "user-agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64)",
         "referer": "https://pokeheroes.com/gc_hangman?",
         "accept": "text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8",
         "accept-language": "es-ES,es;q=0.9,en;q=0.8",
         "upgrade-insecure-requests": "1",
     }
 
 def request_page(sess: requests.Session, cookies: dict, letter: str | None):
     params = {"guess": letter} if letter else None
     r = sess.get(URL, params=params, headers=headers_common(), cookies=cookies, timeout=30)
     r.raise_for_status()
     return r.text
 
 def refresh_round(sess: requests.Session, cookies: dict):
     params = {"_": int(time.time() * 1000)}  # cache-buster
     r = sess.get(URL, params=params, headers=headers_common(), cookies=cookies, timeout=30)
     r.raise_for_status()
     return r.text
 
 def is_game_page(soup: BeautifulSoup) -> bool:
     txt = normalize_text(soup.get_text(" ", strip=True))
     return bool(soup.select("a.letterGuess")) or ("Hangman" in txt and "Guess the word" in txt)
 
 def print_state(raw_word: str | None, soup: BeautifulSoup):
     solved, correct, lives = grab_metrics(soup)
+    current_streak = solved
     if raw_word:
         print(f"Word: {spaced(raw_word)} ")
     else:
         center = soup.find("center")
         approx = normalize_text(center.get_text(" ", strip=True)).upper() if center else "(vacío)"
         print(f"Word: {spaced(approx)} (palabra no encontrada) ")
-    print(f"Solved Hangmen in a row: {solved}")
+    print(f"Racha actual: {current_streak}")
     print(f"Correct Guesses: {correct}")
     print(f"Lives left: {lives}")
+    Path("results.txt").write_text(str(current_streak), encoding="utf-8")
     return solved, correct, lives
 
 def round_finished(raw_word: str | None, lives: str | None) -> bool:
     if raw_word and "_" not in raw_word:
         return True
     try:
         return int(lives) <= 0
     except (TypeError, ValueError):
         return False
 
 def auto_refresh_until_word(sess: requests.Session, cookies: dict, interval=2, max_tries=60):
     """
     Autorefresca hasta que aparezca la palabra.
     Si se detecta el banner de INSTRUCTIONS, espera INSTRUCTION_WAIT_SEC entre intentos.
     """
     last_soup = None
     empty_center_hits = 0
 
     for i in range(1, max_tries + 1):
         html = refresh_round(sess, cookies)
         soup = BeautifulSoup(html, "html.parser")
 
         if not is_game_page(soup):
             Path("last_response.html").write_text(html, encoding="utf-8")
             print("\n❌ No llegó la página del juego. Guardé last_response.html")
 
EOF
)